import {
  electricCollectionOptions,
  ElectricCollectionUtils,
} from "@tanstack/db-collections";
import Constants from "expo-constants";
import { createCollection, type Transaction } from "@tanstack/react-db";
import { Todo, selectTodoSchema } from "../db/schema";
import {parse, parseISO} from "date-fns"

const hostname = new URL(Constants.linkingUri).hostname;
const API_BASE_URL = `http://${hostname}:3001/api`; // Port 3001 from api/index.ts

/**
 * Standalone API client for interacting with the Express backend.
 */
export const apiClient = {
  async getTodos(): Promise<Todo[]> {
    const response = await fetch(`${API_BASE_URL}/todos`);
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} fetching todos`);
    }
    return response.json();
  },

  async getTodoById(id: number): Promise<Todo | null> {
    const response = await fetch(`${API_BASE_URL}/todos/${id}`);
    if (!response.ok) {
      if (response.status === 404) return null;
      throw new Error(`HTTP Error: ${response.status} fetching todo ${id}`);
    }
    return response.json();
  },

  async createTodo(
    todoData: Partial<Omit<Todo, "id" | "created_at" | "updated_at">>,
  ): Promise<{ todo: Todo; txid: number }> {
    const response = await fetch(`${API_BASE_URL}/todos`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(todoData),
    });
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(
        `HTTP Error: ${response.status} creating todo. Body: ${errorBody}`,
      );
    }
    return response.json();
  },

  async updateTodo(
    id: number,
    todoData: Partial<Omit<Todo, "id" | "created_at" | "updated_at">>,
  ): Promise<{ todo: Todo; txid: number }> {
    const response = await fetch(`${API_BASE_URL}/todos/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(todoData),
    });
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(
        `HTTP Error: ${response.status} updating todo ${id}. Body: ${errorBody}`,
      );
    }
    return response.json();
  },

  async deleteTodo(id: number): Promise<{ success: boolean; txid: number }> {
    const response = await fetch(`${API_BASE_URL}/todos/${id}`, {
      method: "DELETE",
    });
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(
        `HTTP Error: ${response.status} deleting todo ${id}. Body: ${errorBody}`,
      );
    }
    return response.json();
  },
};

/**
 * Todo collection with ElectricSQL integration
 */
export const todoCollection = createCollection(
  electricCollectionOptions({
    id: "todos",
    schema: selectTodoSchema,
    // Electric syncs data using "shapes". These are filtered views
    // on database tables that Electric keeps in sync for you.
    shapeOptions: {
      url: `http://${hostname}:3000/v1/shape`,
      params: {
        table: "todos",
      },
      parser: {
        // Parse timestamp columns into JavaScript Date objects
        timestamptz: (date: string) => {
          return parseISO(date);
        },
      },
    },
    getKey: (item) => item.id,
  }),
);

/**
 * Generic mutation function for handling all mutations.
 * This function calls the Express API endpoints defined in /api/index.ts.
 */
export const mutationFn = async ({
  transaction,
}: {
  transaction: Transaction<Partial<Todo>>;
}) => {
  let lastTxid: string | undefined;

  for (const mutation of transaction.mutations) {
    let result: { todo?: Todo; success?: boolean; txid: number };

    // The `item` in the mutation might contain fields like `collection`
    // that the API doesn't expect. We need to strip them or pass only known fields.
    // For simplicity here, we assume the API's validation schemas handle extra fields gracefully
    // or that `mutation.item` is already clean.
    // A more robust solution might involve transforming `mutation.item` based on `insertTodoSchema` or `updateTodoSchema`.

    const { id, created_at, updated_at, ...dataToSync } = mutation.modified;

    switch (mutation.type) {
      case "insert":
        // Ensure `id` is not sent for creation if it's auto-generated by the DB
        // The current API expects `text` and optionally `completed`.
        // `id`, `created_at`, `updated_at` are handled by the DB/API.
        result = await apiClient.createTodo(dataToSync);
        break;
      case "update":
        if (mutation.key === undefined) {
          console.error("Update mutation missing key (ID)");
          throw new Error("Update mutation missing key (ID)");
        }
        result = await apiClient.updateTodo(id!, dataToSync);
        break;
      case "delete":
        if (mutation.key === undefined) {
          console.error("Delete mutation missing key (ID)");
          throw new Error("Delete mutation missing key (ID)");
        }
        result = await apiClient.deleteTodo(mutation.key as number);
        break;
      default:
        throw new Error(`Unknown mutation type: ${mutation.type}`);
    }

    if (result.txid) {
      lastTxid = String(result.txid);
    } else {
      // This case should ideally not happen if the API always returns a txid on success
      console.warn("API response did not include a txid", result);
      // Potentially throw an error or handle missing txid if critical for ElectricSQL
    }
  }

  // If there were any mutations and we have a lastTxid, await it.
  if (lastTxid !== undefined && transaction.mutations.length > 0) {
    const utils = transaction.mutations[0].collection
      .utils as ElectricCollectionUtils;
    // Monitor the incoming sync stream for the database transaction ID
    await utils.awaitTxId(lastTxid);
  } else if (transaction.mutations.length > 0) {
    // This warning indicates that no mutations resulted in a txid, or no mutations were processed.
    // If mutations were processed, this means the API didn't return txids as expected.
    console.warn(
      "No txid found to await after processing mutations, or no mutations were processed.",
    );
  }
};
